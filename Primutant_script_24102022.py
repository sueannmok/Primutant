# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11uzCiZIEIeRK_gN0nq1npWSWDbpZ8oBM

Checks for melting module installation
"""

"""Defining the global variables"""

codon_dict={'F': ['TTT', 'TTC'], 'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'], 'I': ['ATT', 'ATC', 'ATA'], 'M': ['ATG'], 'V': ['GTT', 'GTC', 'GTA', 'GTG'], 'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'], 'P': ['CCT', 'CCC', 'CCA', 'CCG'], 'T': ['ACT', 'ACC', 'ACA', 'ACG'], 'A': ['GCT', 'GCC', 'GCA', 'GCG'], 'Y': ['TAT', 'TAC'], 'Stop': ['TAA', 'TAG', 'TGA'], 'H': ['CAT', 'CAC'], 'Q': ['CAA', 'CAG'], 'N': ['AAT', 'AAC'], 'K': ['AAA', 'AAG'], 'D': ['GAT', 'GAC'], 'E': ['GAA', 'GAG'], 'C': ['TGT', 'TGC'], 'W': ['TGG'], 'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'], 'G': ['GGT', 'GGC', 'GGA', 'GGG']}
ecoli_dict={'F': ['TTT', 'TTC'], 'L': ['TTA', 'TTG', 'CTT', 'CTG'], 'I': ['ATT', 'ATC'], 'M': ['ATG'], 'V': ['GTT', 'GTC', 'GTA', 'GTG'], 'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'], 'P': ['CCT', 'CCC', 'CCA', 'CCG'], 'T': ['ACT', 'ACC', 'ACA', 'ACG'], 'A': ['GCT', 'GCC', 'GCA', 'GCG'], 'Y': ['TAT', 'TAC'], 'Stop': ['TAA', 'TAG', 'TGA'], 'H': ['CAT', 'CAC'], 'Q': ['CAA', 'CAG'], 'N': ['AAT', 'AAC'], 'K': ['AAA', 'AAG'], 'D': ['GAT', 'GAC'], 'E': ['GAA', 'GAG'], 'C': ['TGT', 'TGC'], 'W': ['TGG'], 'R': ['CGT', 'CGC'], 'G': ['GGT', 'GGC', 'GGA', 'GGG']}
mammalian_dict={'F': ['TTT', 'TTC'], 'L': ['TTG', 'CTT', 'CTC', 'CTG'], 'I': ['ATT', 'ATC', 'ATA'], 'M': ['ATG'], 'V': ['GTT', 'GTC', 'GTG'], 'S': ['TCT', 'TCC', 'TCA', 'AGT', 'AGC'], 'P': ['CCT', 'CCC', 'CCA'], 'T': ['ACT', 'ACC', 'ACA', 'ACG'], 'A': ['GCT', 'GCC', 'GCA'], 'Y': ['TAT', 'TAC'], 'Stop': ['TAA', 'TAG', 'TGA'], 'H': ['CAT', 'CAC'], 'Q': ['CAA', 'CAG'], 'N': ['AAT', 'AAC'], 'K': ['AAA', 'AAG'], 'D': ['GAT', 'GAC'], 'E': ['GAA', 'GAG'], 'C': ['TGT', 'TGC'], 'W': ['TGG'], 'R': ['CGT', 'CGC', 'CGG', 'AGA', 'AGG'], 'G': ['GGT', 'GGC', 'GGA', 'GGG']}
ala_codon = ['GCT', 'GCC', 'GCA', 'GCG']
nucleotide_list = ["A", "T", "C", "G"]
#OCT 24 2022, Added new codon table for code funtionality.
codon_table = {
        'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M','ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T','AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
        'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R','CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L','CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
        'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q','CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R','GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
        'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A','GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E','GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
        'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S','TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L','TAC':'Y', 'TAT':'Y','TGC':'C', 'TGT':'C',
        'TGG':'W', 'TAA':'Stop', 'TAG':'Stop','TGA':'Stop'
}
high_test = int(0)
med_test = int(0)
low_test = int(0)


"""Import melting, csv, and primer3 file modules"""

import melting
import csv
import primer3

"""Prompts user until entering a valid sequence for the program"""

def seq_test():
    #allows user reinuput in case it is not valid
    global seq
    valid = False
    while valid != True:
        query=input("sequence: Make sure 1)to include at least 30 nucleotides upstream and downstream of region of interest and 2)the nucleotides corresponding to the start codon:")
        seq_temp=query.replace(" ","")
        seq_temp=seq_temp.replace("\n","")
        seq =seq_temp.upper()
        for base in seq:
            if base not in nucleotide_list:
                valid = False
                print("This is not a valid DNA sequence, please try again.")
                break
            else:
                valid = True

"""Prompts user until entering a valid position of a start codon"""

def start_check():
    while True:
    #allows user to input location without restarting program
    #OCT 24 2022, Added edit to allow alternative start codons
        global start
        start=int(input("Enter nucleotide that is position 1 of start codon:"))
        start_codon=(seq[start-1:start+2])
        if start_codon !="ATG":
            print("translated codon:",start_codon)
            bypass=input("This is not an AUG start codon, continue anyways? Y/N: ")
            if bypass == "Y":
                break
            else:
                pass
        else:
            #print(start)
            print("This is a start codon. You are okay to continue")
            break

def Dict_select():
    while True:
        global Mut_dict
        Mut_dict=str(input("What type of cells will be used: A for E.coli, B for Mamallian:"))
        if Mut_dict == "A":
            Mut_dict = ecoli_dict
            break
        if Mut_dict == "B":
            Mut_dict = mammalian_dict
            break
        else:
            print("this is not a valid response")

"""Checks the defined region of mutation with the user before continuing"""

def reg_check():
    #allows for user reinput if wrong
    to_continue = False
    while to_continue == False:
        global reg_start
        global reg_end
        global gc_start
        #user inputs sites for mutagenesis
        reg_start=int(input("Enter starting nucleotide for region to be mutated:"))
        reg_end=int(input("Enter ending nucleotide for region to be mutated:"))
        print ("first three codons:",seq[reg_start-1:reg_start+2],seq[reg_start+2:reg_start+5],seq[reg_start+5:reg_start+8])
        print ("last three codons:",seq[reg_end-8:reg_end-5],seq[reg_end-5:reg_end-2],seq[reg_end-2:reg_end+1])
        check = input("If this is correct 'Y' to continue, otherwise type 'N':")
        if check.upper() == "Y":
            to_continue = True
            gc_start =(reg_start-1)
        elif check.upper() != 'Y' or 'N':
            print('Please enter a valid response')

"""Choosing the mutation types that one would like to perform on the region of mutation"""

def choose_mut():
    finish = False
    choices = []
    while finish == False:
        user_choice = input("Type A for custom scan\n Type B for deep mutational scan\n Type C for phosphorylation site mutagenesis\n Type 'END' to end selection\n")
        if user_choice.upper() in ('A', 'B', 'C'):
            if user_choice.upper() not in choices:
                choices.append(user_choice.upper())
                print(choices)
        elif user_choice.upper() == 'END':
                finish = True
                return choices
        else:
            print('Please enter a valid response')

"""Determining codon position"""

def conv_pos_codonnum(i):
    pos=int(((((i+1)-start)/3))+1)
    return (pos)

"""Defining the current codon and the amino acids that it codes for"""

def curr_codon(i):
    curr_codon=seq[i:i+3]
    for key,value in codon_dict.items():
        if curr_codon in value:
            return (key)

"""Creates the primer sequence before the mutated codon"""

def melt_primer_pre(i):
    min_nuc=14
    min_temp=float(63)
    pre = seq[i-min_nuc:i+0]
    while melting.temp(pre)<min_temp:
        min_nuc+=1
        pre = seq[i-min_nuc:i+0]
    else:
        return pre

"""Creates the primer sequence after the mutated codon"""

def melt_primer_post(i):
    min_nuc=14
    min_temp=float(63)
    post=seq[i+3:i+3+min_nuc]
    while melting.temp(post)<min_temp:
        min_nuc+=1
        post=seq[i+3:i+3+min_nuc]
    else:
        return post

"""Checks and prints a warning if the melting temperature is above 85"""

def tmcheck(x):
    if x > float(85):
        return "Tm is above 85"
    else:
        return ""


def GC_per(sequence, tmp):
    GC_list = ["G","g","c","C"]
    index = 0
    gc_count = 0
    global low_test
    global high_test
    global med_test
    global gc_start
    while index < len(sequence):
        if sequence[index] in GC_list:
            gc_count += 1
        index += 1
    gc_percent = 100*gc_count/(len(sequence))
    if gc_percent < 40:
        if low_test <= 3 and tmp > gc_start:
            low_test += 1
            gc_start += 9
            return "Use this primer pair to test LOW GC content"
        else:
            return ""
    elif gc_percent > 60:
        if high_test <= 3 and tmp > gc_start:
            high_test += 1
            gc_start += 9
            return "Use this primer pair to test HIGH GC content"
        else:
            return ""
    else:
        if med_test <= 3 and tmp > gc_start:
            med_test += 1
            gc_start += 9
            return "Use this primer pair to test MEDIUM GC content"
        else:
            return ""

def gcpercent(x):
    capgc = x.upper()
    gcx = capgc.count("C") + capgc.count("G")
    gcpercent = gcx/len(x)*100
    return gcpercent

"""Creates the reversed complement strand"""

def rev_comp(seq):
    reverse=seq.maketrans('atcgATCG','tagcTAGC')
    complement=seq.translate(reverse)
    complement_list=list(complement)
    rev_comp_seq=complement_list[::-1]
    return (''.join(rev_comp_seq))
#OCT 24, Added new function to translate nucleotide sequence to protein sequences
def seq_translate(seq, dictionary):
    global aa_seq
    global mut_seq
    aa_seq = ""
    mut_seq = ""
    index = start
    while index < len(seq):
        cod_id=seq[index:index+3]
        for codon, aa in dictionary.items():
            if codon == cod_id:
                if aa == 'Stop':
                    index = len(seq)
                else:
                    aa_seq = aa_seq + aa
        index += 3
    for i in range(reg_start-1,reg_end-3,3):
        cod_id=seq[i:i+3]
        for codon, aa in dictionary.items():
            if codon == cod_id:
                if aa == 'Stop':
                    index = len(seq)
                else:
                    mut_seq = mut_seq + aa







"""Creates a output file with appropriate headings"""

def create_output():
    #changes the file name to be "genename_mutagenesis.csv"
    #OCT 24 2022, Added new rows to accomodate changes to include amino acids
    global csv_name
    csv_name = gene_name + "_mutagenesis" + ".csv"
    csv_name = csv_name.strip()
    seq_translate(seq, codon_table)
    with open(csv_name,'w',newline='') as f:
        thewriter=csv.writer(f)
        thewriter.writerow(["DNA sequence", seq])
        thewriter.writerow(["Amino acid sequence", aa_seq])
        thewriter.writerow(["Amino acid mutation region", mut_seq])
        thewriter.writerow(["start position", start])
        thewriter.writerow(["start of region to be mutated",reg_start])
        thewriter.writerow(["end of region to be mutated",reg_end])
        thewriter.writerow(['codon','position number','primer name','primer sequence', 'melting temp (Celsius)', 'GC content (%)', 'Changed codon, # of nucleotide mismatches', 'Warnings', 'test primer candidate'])
""" MADE SOME EDITS ABOVE TO THE EXCEL OUTPUT - Kerry"""

"""Checks for the difference between the dictionary and the current codon"""

def check_diff(codon, dictionary, cod_id):
    codon_index = 0
    difference = 0
    while codon_index < 3:
        if cod_id[codon_index] != codon[codon_index]:
            difference += 1
        codon_index += 1
        dictionary[codon] = difference


"""Writes the result of primer design in the output file"""
"""ADDED INPUT mut_num FOR # OF NUCLEOTIDE CHANGES"""
def write_result(i, x, p, tmp2, tmp3, aa, mut, mut_num):
    warning2 = "This sequence may have errors: "
    warning3 = "This sequence may have errors: "
    primer_name_for=(gene_name+"_"+x+str(p)+aa+"_for")
    tmp2.append(primer_name_for)
    primer_name_rev=(gene_name+"_"+x+str(p)+aa+"_rev")
    tmp3.append(primer_name_rev)
    before=melt_primer_pre(i)
    after=melt_primer_post(i)
    for_primer=before+mut+after
    tmp2.append(for_primer)
    rev_primer=rev_comp(for_primer)
    tmp3.append(rev_primer)
    forprimcap = for_primer.upper()
    revprimcap = rev_primer.upper()
    tmforprim = melting.temp(forprimcap)
    tmrevprim = melting.temp(revprimcap)
    gcpercentfor = gcpercent(for_primer)
    gcpercentrev = gcpercent(rev_primer)
    tmp2.append("%.2f" % tmforprim)
    tmp3.append("%.2f" % tmrevprim)
    tmp2.append("%.2f" % gcpercentfor)
    tmp3.append("%.2f" % gcpercentrev)
    tmp2.append(mut_num)
    tmp3.append(mut_num)
    a=StructureCheck("hairpins", primer3.calcHairpin(for_primer), tmforprim, warning2, tmp2)
    b=StructureCheck("hairpins", primer3.calcHairpin(rev_primer), tmrevprim, warning3, tmp3)
    """ OUR PRIMERS ALWAYS FORM HETERODIMERS SO I REMOVED THIS - KERRY
    c=StructureCheck("heterodimers", primer3.calcHeterodimer(for_primer, rev_primer), tmforprim, warning2, tmp2)
    """
    d=StructureCheck("homodimers", primer3.calcHomodimer(for_primer), tmforprim, warning2, tmp2)
    e=StructureCheck("homodimers", primer3.calcHomodimer(rev_primer), tmrevprim, warning3, tmp3)
    f=tmcheck(tmforprim)
    g=tmcheck(tmrevprim)
    gcfor = GC_per(for_primer, i)
    # gcrev is not needed - SM
    #gcrev = GC_per(rev_primer, i)
    #moved str(gcfor) and str(gcrev) because redundant. added commas for readability -SM
    combfor = str(a) + (', ') + str(d) + (', ') + str(f)
    combrev = str(b) + (', ') + str(e) + (', ') + str(g)
    tmp2.append(combfor)
    tmp3.append(combrev)
    """MOVE THINGS AROUND SLIGHTLY TO RECOMMEND PRIMERS TO TEST AT THE END"""
    tmp2.append(str(gcfor))
    tmp3.append(str(gcfor))
    #Adds the generated primers to the csv file
    with open(csv_name,'a+',newline='') as f:
        thewriter=csv.writer(f)
        thewriter.writerow(tmp2)
        thewriter.writerow(tmp3)



"""generates primers for mutagenesis"""

def mutation(i, dictionary, cod_id, aa):
    x = curr_codon(i)
    p = conv_pos_codonnum(i)
    #sorts dictionary by values (differences from original sequence) so that the mutations with least changes are first
    dictionary = sorted(dictionary.items(), key = lambda kv:(kv[1], kv[0]))

    tmp2=[cod_id,p]
    tmp3=[cod_id,p]
    #selects one of the mutations with the lowest amount of changes
    mut = dictionary[0][0].lower()
    orig_cod = cod_id
    changed_cod = str(dictionary[0])

    mut_num = orig_cod + " to " + changed_cod[2:5] + ", " + changed_cod[8]

    #print(mut)
    #doesn't use mutations that are stop codons
    if aa != "Stop":
        write_result(i, x, p, tmp2, tmp3, aa, mut, mut_num)

"""Code block for Deep Mutation"""

def deep_mutation():
    with open(csv_name,'a+',newline='') as f:
        thewriter = csv.writer(f)
        thewriter.writerow(['Deep_Mutation'])
    for i in range(reg_start-1,reg_end-3,3):
        cod_id=seq[i:i+3]
        #checks for similarity between original sequence and the mutation possibilites
        for aa, codons in Mut_dict.items():
            #skips entire primer design when dict amino acid is same as the actual
            if cod_id not in codons:
                mutation_dict = {}
                for codon in codons:
                    check_diff(codon, mutation_dict, cod_id)
                mutation(i, mutation_dict, cod_id, aa)

"""Code block for custom scan"""

def custom_scan():
    with open(csv_name,'a+',newline='') as f:
        thewriter = csv.writer(f)
        thewriter.writerow(['Custom_Scan'])

    scanmutselection = input("Please type the one letter name for amino acid: ")
    scanmutselection = scanmutselection.upper()
    scanmutselection = scanmutselection.strip()
    aa = scanmutselection
    print (codon_dict[scanmutselection])
    for i in range(reg_start-1,reg_end-3,3):
        cod_id=seq[i:i+3]
        if seq[i:i+3] in codon_dict[scanmutselection]:
            s=conv_pos_codonnum(i)

            tmp1=[cod_id]
            tmp1.append(s)
            #Added more info so there arent simply two blanks
            tmp1.append("N/A")
            phrase = "Codon position {} is already {}.".format(s, scanmutselection)
            tmp1.append(phrase)
            with open(csv_name,'a+',newline='') as f:
                thewriter=csv.writer(f)
                thewriter.writerow(tmp1)
        else:
            newdict = {}
            for x in Mut_dict[scanmutselection]:
                check_diff(x, newdict, cod_id)
            mutation(i, newdict, cod_id, aa)

"""Code block for phosphorylation site mutagenesis"""

def phos_mut():
    #Asks user input for primer generation for phosphorylation mutagenesis type (A for phosphodeficient, and B for phosphomimetics)
    choosing = True
    while choosing == True:
        prompt = input('Please enter A for the phophorylation-deficient mutagenesis, or B for phosphomimetics mutagenesis:')
        prompt = prompt.strip()
        prompt = prompt.replace(' ', '')
        if prompt.upper() == 'A' or prompt.upper() == 'B':
            choosing = False
        else:
            print('Please enter a valid choice')

    with open(csv_name,'a+',newline='') as f:
        thewriter = csv.writer(f)
        thewriter.writerow(['Phosphorylation_Site_Mutagenesis'])
    #print('phos_mut')

    if prompt.upper() == 'A':
        aa = 'A'
    else:
        aa = 'D'
    #if the codon results in S, T, or Y residues, it replaces the codon with a codon for A(for phosphorlyation-deficient mutagenesis), or D(for phosphormimetic mutagenesis)
    phos_aa = ('S', 'T', 'Y')
    for letter in phos_aa:
        for i in range(reg_start-1,reg_end-3,3):
            cod_id=seq[i:i+3]
            if seq[i:i+3] in codon_dict[letter]:
                print(letter + ' found')
                newdict = {}
                for x in Mut_dict[aa]:
                    check_diff(x, newdict, cod_id)
                mutation(i, newdict, cod_id, aa)

"""Code block for checking if potential hindering structures (eg. hairpins, hetero/homodimers) will be present in primer"""

def StructureCheck(Structure, Structure_Check, primTm, warning, tmp):
    """
    Checks for potential complications in primers

    Parameters: Structure = Structure being checked
                Structure_Check = type of potential structure being investigated
                primTm = Tm of primer
                warning = warning statement that will be added if structure present
                tmp = the line in the csv file where the info will be written
                *Structure_Check functions are from primer3 module
    """
    Structure_present = str(Structure_Check)
    if "True" in Structure_present:
        tm = Structure_present.find("tm")
        temp = Structure_present[tm + 3 : tm + 9]
        temp = temp.replace(",", "")
        if float(temp) > primTm - 10:
            warning = warning + "Hairpins may occur with Tm of " + temp
            return warning

"""Main function:"""

def main():

    global gene_name
    gene_name = input('Please enter the gene name with no spaces or special characters: ')
    seq_test()
    start_check()
    reg_check()
    Dict_select()
    mutations = choose_mut()
    create_output()


    if 'A' in mutations:
        print ('Custom Scan')
        custom_scan()
    if 'B' in mutations:
        print('Deep Mutation')
        deep_mutation()
    if 'C' in mutations:
        print('phosphorylation site mutagenesis')
        phos_mut()

    #print(*mutations)
    #print (seq)
    #print(start)
main()
